/*
  This file is part of JOP, the Java Optimized Processor
    see <http://www.jopdesign.com/>

  Copyright (C) 2009, Benedikt Huber (benedikt.huber@gmail.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/* Autogenerated using ERB (tiny ruby, part of ruby distributions) */
/* erb LoadOnReturn.erb > LoadOnReturn.java */

package wcet.devel;

import com.jopdesign.sys.Const;
import com.jopdesign.sys.Native;
/*
 * Load on Return Test for variable block method caches.
 * NOTE: Analysis is trivial without cache
 * TODO: Add real measurements (I'm currently lacking VMWare)
 * dspio, 16 blocks, 4096K cache
 * JSIM:                   26681
 * UPPAAL[fixed 14.3.09]:  26668 (still of by ~13 - INVESTIGATE !!)
 * IPET:                   32877
 * With loop: 
 * JSIM:                   2,668,635
 * UPPAAL[fixed 14.3.09]:  2,668,647
 * IPET:                   3,294,330
 *
 * Edit erb file if you need different cache settings
 */
<% cache_blocks = 16 %>
<% cache_size   = 1024 %>
<% bytes_per_block = cache_size*4 / cache_blocks %>
public class LoadOnReturn {
    final static int CACHE_FLUSH = -51;
    final static int CACHE_RD_COST = -52;
    
	/**
	 * Set to false for the WCET analysis, true for measurement
	 */
    final static boolean MEASURE = false;
    final static boolean MEASURE_CACHE = false;
	static int ts, te, to;
    static int cs, ce;

	public static void main(String[] args) {

		ts = Native.rdMem(Const.IO_CNT);
		te = Native.rdMem(Const.IO_CNT);
		to = te-ts;
		invoke();
		int val = te-ts-to;
		int cacheCost = ce-cs;
		if (MEASURE)       { System.out.print("wcet: "); System.out.println(val);             }
		if (MEASURE_CACHE) { System.out.print("cache cost: "); System.out.println(cacheCost); }
	}
	
	static void invoke() {
		if(MEASURE_CACHE) {
		    cs = Native.rdMem(CACHE_RD_COST);
		    Native.wrMem(1,CACHE_FLUSH);
		}
	    measure();
		if (MEASURE) te = Native.rdMem(Const.IO_CNT);
		if (MEASURE_CACHE) ce = Native.rdMem(CACHE_RD_COST);
	}
	<% fun_count = cache_blocks / 2 %>
	/* Generated for <%= cache_blocks %> blocks, <%= cache_size %> words cache */
	/* For a 2*n-cache block:
	   - f_i spans 2 blocks
	   - we load the cache with measure(), f_n,f_n-1,...f_1
	   - ### ^|f_n(0)|f_n(1)|...|f_1(0)|f_1(0)|
	   - measure and all-fit are loaded, invalidating  f_n
	   - ### ^|f_n-1(0)|...|f_1(0)|f_1(1)|measure|callallfit
	   - then we call the all-fit region f1 (which in turn invokes f2,..,f_n-1)
	   - the call to f_n is a miss, overwriting f_{n-1}
	   - ### ^|f_n-2(0)|f_n-2(1)|...|f_1(0)|f_(1)|measure|callallfit|f_n(0)|f_n(1)|
	   - When returning, the accesses to f_n-1,f_n-2,...,f_1,callallfit and measure are cache misses
	   - ### ^|f_n-1(0)|f_n-1(1)|f_1(1)|...|callallfit|measure
	   - Luckily, we can loop at this point if we want
	 */
	static void measure() {
		if (MEASURE) ts = Native.rdMem(Const.IO_CNT);
		// Optional: loop
		// for(int i = 0; i < 100; i++) {
		<% fun_count.downto(1) do |k| %>
		f_<%= k %>();
		<% end %>
		callallfit();
		// }
	}
	static void callallfit() {
	    f_1();
	}
	<% 1.upto(fun_count) do |k| %>
	static void f_<%= k %>() {
	    <% if k != fun_count %>
	    f_<%= k+1 %>();
	    <% end %>
	    int val = 23;
	    /* Rest takes 8 bytes, val += 123 takes 3 bytes, and we want two fill two blocks */
	    <% size_wanted = bytes_per_block + 1 %>
	    <% needed_iters = (size_wanted+2) / 3 %>
	    /* Inserting <%= needed_iters %> times val+=123 */
	    <% needed_iters.times do %>val += 123;  <% end %>
	}
	<% end %>
}
